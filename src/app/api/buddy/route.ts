import { auth } from "@clerk/nextjs/server";
import OpenAI from "openai";
import { env } from "@/env.js";
import { db } from "@/server/db";
import { Account } from "@/lib/accounts";
import { withRequestId } from "@/lib/logging/with-request-id";
import { checkDailyCap, recordUsage } from "@/lib/ai-usage";
import { checkUserRateLimit } from "@/lib/rate-limit";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

interface ChatRequest {
  messages: Array<{
    role: "user" | "assistant" | "system";
    content: string;
    emailData?: {
      subject: string;
      body: string;
      suggestions?: Array<{ subject: string; body: string }>;
    };
  }>;
}

function isEmailRequest(
  message: string,
  previousMessages?: Array<{
    role: string;
    emailData?: { subject: string; body: string };
  }>,
): boolean {
  const emailKeywords = [
    "email",
    "mail",
    "write an email",
    "write a mail",
    "make an email",
    "make a mail",
    "generate an email",
    "generate a mail",
    "create an email",
    "create a mail",
    "compose",
    "draft",
    "send",
    "subject",
    "follow up",
    "follow-up",
    "thank you",
    "thank you note",
    "meeting",
    "introduction",
    "intro",
    "request",
    "reply",
    "response",
    "cold mail",
    "cold email",
    "outreach",
    "proposal",
    "status update",
    "update",
    "hire",
    "hiring",
    "job",
    "application",
    "cover letter",
  ];
  const lowerMessage = message.toLowerCase();

  if (emailKeywords.some((keyword) => lowerMessage.includes(keyword))) {
    return true;
  }

  if (/make\s+(me\s+)?(a|an|one)\s+.*\s+(mail|email)/i.test(message)) {
    return true;
  }

  if (/can\s+you\s+.*\s+(mail|email)/i.test(message)) {
    return true;
  }

  if (previousMessages && previousMessages.length > 0) {
    const hasPreviousEmail = previousMessages.some(
      (msg) => msg.role === "assistant" && msg.emailData,
    );

    if (hasPreviousEmail) {
      const regenerationKeywords = [
        "better",
        "improve",
        "regenerate",
        "another",
        "different",
        "change",
        "redo",
        "revise",
        "update",
        "modify",
        "edit",
        "rewrite",
        "new version",
        "another version",
        "different version",
        "more explanatory",
        "more detailed",
        "expand",
        "bigger",
        "longer",
        "lengthy",
        "comprehensive",
        "elaborate",
        "extend",
      ];

      if (
        regenerationKeywords.some((keyword) => lowerMessage.includes(keyword))
      ) {
        return true;
      }
    }
  }

  return false;
}

function extractEmailAddresses(text: string): string[] {
  const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
  const matches = text.match(emailRegex);
  return matches || [];
}

function isSendEmailRequest(message: string): boolean {
  const lowerMessage = message.toLowerCase();
  const sendKeywords = [
    "send",
    "send this",
    "send it",
    "send the email",
    "send that",
    "send to",
    "send this email",
    "send that email",
    "send it to",
    "send this to",
    "send that to",
    "can you send",
    "please send",
    "send the",
  ];
  const hasEmail = extractEmailAddresses(message).length > 0;

  const hasSendKeyword = sendKeywords.some((keyword) =>
    lowerMessage.includes(keyword),
  );
  return hasEmail && hasSendKeyword;
}

async function extractEmailFromConversation(
  messages: Array<{
    role: string;
    content: string;
    emailData?: { subject: string; body: string };
  }>,
  openai: OpenAI,
  options?: { userId?: string; accountId?: string },
): Promise<{ subject: string; body: string } | null> {
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    if (
      msg &&
      msg.role === "assistant" &&
      msg.emailData &&
      msg.emailData.subject &&
      msg.emailData.body
    ) {
      return {
        subject: msg.emailData.subject,
        body: msg.emailData.body,
      };
    }
  }

  const conversationContext = messages
    .slice(-20)
    .map((msg) => {
      if (!msg) return "";
      let content = `${msg.role}: ${msg.content}`;

      if (msg.emailData) {
        content += `\n[Email Data Available]\nSubject: ${msg.emailData.subject}\nBody: ${msg.emailData.body}`;
      }
      return content;
    })
    .filter((content) => content !== "")
    .join("\n\n");

  const extractionPrompt = `Based on the conversation below, extract the MOST RECENT email that was generated. Look for the subject line and complete email body that was created by the assistant.

IMPORTANT: 
- Look for the most recent email generation in the conversation
- The email should have been generated by the assistant in response to a user request
- Extract the complete subject and body text
- If the conversation shows "Here's your draft:" or similar, the email details should follow

Return ONLY valid JSON in this exact format:
{
  "subject": "Email subject here",
  "body": "Complete email body here"
}

If no email can be found, return: {"subject": null, "body": null}

Conversation:
${conversationContext}`;

  try {
    const completion = await openai.chat.completions.create({
      model: "anthropic/claude-3.5-sonnet",
      messages: [
        {
          role: "system",
          content:
            "You are a helpful assistant that extracts email information from conversations. You must find the most recently generated email with both subject and body. Return ONLY valid JSON, no other text.",
        },
        {
          role: "user",
          content: extractionPrompt,
        },
      ],
      max_tokens: 2000,
      temperature: 0.1,
      response_format: { type: "json_object" },
    });

    if (options?.userId) {
      const u = completion.usage;
      recordUsage({
        userId: options.userId,
        accountId: options.accountId,
        operation: "buddy",
        inputTokens: u?.prompt_tokens ?? 0,
        outputTokens: u?.completion_tokens ?? 0,
        model: completion.model ?? undefined,
      });
    }

    const content = completion.choices[0]?.message?.content || "";
    try {
      const parsed = JSON.parse(content);
      if (
        parsed.subject &&
        parsed.body &&
        parsed.subject !== "null" &&
        parsed.body !== "null" &&
        parsed.subject.trim() !== "" &&
        parsed.body.trim() !== ""
      ) {
        return { subject: parsed.subject, body: parsed.body };
      }
    } catch { }
  } catch (error) {
    console.error("Error extracting email from conversation:", error);
  }

  return null;
}

function removeAllSymbols(text: string): string {
  text = text.replace(/\*+/g, "");

  text = text.replace(/^\s*-\s+/gm, "");

  text = text.replace(/â€¢/g, "");

  text = text.replace(/^\s*[â–ªâ–«â—¦â€£âƒ]\s+/gm, "");

  text = text.replace(/\n\s*\n\s*\n/g, "\n\n");

  return text;
}

function enforceEmailFormatting(text: string): string {
  if (!text || typeof text !== "string") return text;

  text = text.replace(/([.!?])\s*\n([A-Z][a-z])/g, "$1\n\n$2");
  text = text.replace(/([a-z0-9])\s*\n([A-Z][a-z])/g, "$1\n\n$2");

  let paragraphs = text
    .split(/\n\n+/)
    .map((p) => p.trim())
    .filter((p) => p);

  if (paragraphs.length === 1) {
    const singlePara = paragraphs[0] || "";
    const sentenceCount = (singlePara.match(/[.!?]+/g) || []).length;

    if (sentenceCount > 2) {
      paragraphs = [];

      const greetingMatch = singlePara.match(
        /^((?:Dear|Hi|Hello)\s+[^,]+,\s*|[A-Z][a-z]+,\s*)/i,
      );
      let processedText = singlePara;
      if (greetingMatch) {
        paragraphs.push(greetingMatch[0].trim());
        processedText = singlePara.substring(greetingMatch[0].length).trim();
      }

      let closing = "";
      const closingPatterns = [
        /(Best regards|Sincerely|Thank you|Regards|Kind regards),?\s*[A-Z][a-z\s]*$/i,
        /(Best regards|Sincerely|Thank you|Regards|Kind regards),/i,
      ];

      for (const pattern of closingPatterns) {
        const closingMatch = processedText.match(pattern);
        if (closingMatch) {
          closing = closingMatch[0].trim();
          processedText = processedText
            .substring(0, processedText.length - closingMatch[0].length)
            .trim();
          break;
        }
      }

      const sentences: string[] = processedText.match(/[^.!?]+[.!?]+/g) || [];

      if (sentences.length === 0) {
        const manualSplit = processedText.split(/([.!?]+\s+)/);
        for (let i = 0; i < manualSplit.length; i += 2) {
          const sentence = (manualSplit[i] || "") + (manualSplit[i + 1] || "");
          if (sentence.trim()) sentences.push(sentence.trim());
        }
      }

      let currentPara = "";
      for (const sentence of sentences) {
        const trimmed = sentence.trim();
        if (!trimmed || trimmed.length < 5) continue;

        const currentSentenceCount = (currentPara.match(/[.!?]+/g) || [])
          .length;
        if (
          currentSentenceCount >= 2 ||
          currentPara.length + trimmed.length > 250
        ) {
          if (currentPara.trim()) {
            paragraphs.push(currentPara.trim());
          }
          currentPara = trimmed;
        } else {
          currentPara += (currentPara ? " " : "") + trimmed;
        }
      }
      if (currentPara.trim()) {
        paragraphs.push(currentPara.trim());
      }

      if (closing) paragraphs.push(closing);
    }
  }

  const finalParagraphs: string[] = [];

  for (const para of paragraphs) {
    if (!para) continue;

    const isGreeting = /^(Dear|Hi|Hello)\s/i.test(para);
    const isClosing =
      /^(Best regards|Sincerely|Thank you|Regards|Kind regards),/i.test(para);
    const isList = /^(\d+\.|[a-z]\.)\s/.test(para);

    if (isGreeting || isClosing || isList) {
      finalParagraphs.push(para);
      continue;
    }

    const sentenceCount = (para.match(/[.!?]+/g) || []).length;
    if (sentenceCount >= 2 || para.length > 250) {
      const sentences = para.match(/[^.!?]+[.!?]+/g) || [];

      if (sentences.length > 1) {
        let currentPara = "";
        for (const sentence of sentences) {
          const trimmed = sentence.trim();
          if (!trimmed) continue;

          const currentSentenceCount = (currentPara.match(/[.!?]+/g) || [])
            .length;
          if (
            currentSentenceCount >= 2 ||
            currentPara.length + trimmed.length > 250
          ) {
            if (currentPara.trim()) {
              finalParagraphs.push(currentPara.trim());
            }
            currentPara = trimmed;
          } else {
            currentPara += (currentPara ? " " : "") + trimmed;
          }
        }
        if (currentPara.trim()) {
          finalParagraphs.push(currentPara.trim());
        }
      } else {
        finalParagraphs.push(para);
      }
    } else {
      finalParagraphs.push(para);
    }
  }

  let result = finalParagraphs.join("\n\n");
  result = result.replace(/\n{3,}/g, "\n\n").trim();

  return result;
}

function normalizeEmailFormatting(text: string): string {
  if (!text || typeof text !== "string") return text;

  const newlineCount = (text.match(/\n/g) || []).length;
  const hasVeryFewNewlines = newlineCount < 3;
  const hasMultipleSentences = (text.match(/[.!?]+/g) || []).length > 2;

  if (hasVeryFewNewlines && hasMultipleSentences) {
    let processedText = text.trim();
    const paragraphs: string[] = [];

    const greetingMatch = processedText.match(
      /^((?:Dear|Hi|Hello)\s+[^,]+,\s*|[A-Z][a-z]+,\s*)/i,
    );
    if (greetingMatch) {
      paragraphs.push(greetingMatch[0].trim());
      processedText = processedText.substring(greetingMatch[0].length).trim();
    }

    let closing = "";
    const closingPatterns = [
      /(Best regards|Sincerely|Thank you|Regards|Kind regards),\s*[^\n]*$/i,
      /(Best regards|Sincerely|Thank you|Regards|Kind regards),?\s*[A-Z][a-z]+\s*$/i,
    ];

    for (const pattern of closingPatterns) {
      const closingMatch = processedText.match(pattern);
      if (closingMatch) {
        closing = closingMatch[0].trim();
        processedText = processedText
          .substring(0, processedText.length - closingMatch[0].length)
          .trim();
        break;
      }
    }

    const sentenceRegex = /[^.!?]+[.!?]+(?=\s|$)/g;
    const sentences: string[] = processedText.match(sentenceRegex) || [];

    if (sentences.length === 0) {
      const simpleSplit = processedText.split(/([.!?]+\s+)/);
      for (let i = 0; i < simpleSplit.length; i += 2) {
        const sentence = (simpleSplit[i] || "") + (simpleSplit[i + 1] || "");
        if (sentence.trim()) sentences.push(sentence.trim());
      }
    }

    let currentPara = "";
    for (const sentence of sentences) {
      const trimmed = sentence.trim();
      if (!trimmed || trimmed.length < 5) continue;

      const currentSentenceCount = (currentPara.match(/[.!?]+/g) || []).length;

      if (
        currentSentenceCount >= 2 ||
        (currentPara.length + trimmed.length > 250 && currentPara.length > 0)
      ) {
        if (currentPara.trim()) {
          paragraphs.push(currentPara.trim());
        }
        currentPara = trimmed;
      } else {
        currentPara += (currentPara ? " " : "") + trimmed;
      }
    }
    if (currentPara.trim()) {
      paragraphs.push(currentPara.trim());
    }

    if (closing) paragraphs.push(closing.trim());

    text = paragraphs.join("\n\n");
  }

  text = text.replace(/[ \t]+$/gm, "");

  text = text.replace(/\n{3,}/g, "\n\n");

  text = text.replace(/([.!?])\s*\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/([a-z]),\s*\n([A-Z][a-z])/g, "$1,\n\n$2");

  text = text.replace(/([^\n])\n(\d+\.\s)/g, "$1\n\n$2");

  text = text.replace(/([^\n])\n([a-z]\.\s)/g, "$1\n\n$2");

  text = text.replace(/([a-z0-9]\.\s[^\n]+)\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(
    /([^\n])\n([A-Z][A-Za-z\s]{2,40})\n([A-Z][a-z])/g,
    "$1\n\n$2\n\n$3",
  );

  text = text.replace(/([A-Z][A-Za-z\s]{2,40})\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/(\d+\.\s[A-Z][^\n]+)\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/([a-z.!?])\s*\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/(Dear [^,]+,\s*)\n([A-Z])/g, "$1\n\n$2");
  text = text.replace(/(Hi [^,]+,\s*)\n([A-Z])/g, "$1\n\n$2");
  text = text.replace(/(Hello [^,]+,\s*)\n([A-Z])/g, "$1\n\n$2");

  text = text.replace(
    /([^\n])\n(Best regards|Sincerely|Thank you|Regards|Kind regards),/g,
    "$1\n\n$2,",
  );

  text = text.replace(/([a-z0-9.!?])\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/\n{1}\n{1,}/g, "\n\n");

  text = text.trim();

  const initialParagraphs = text.split("\n\n").filter((p) => p.trim());
  const reconstructedParagraphs: string[] = [];

  for (const para of initialParagraphs) {
    const trimmed = para.trim();
    if (!trimmed) continue;

    const isGreeting = /^(Dear|Hi|Hello)\s/i.test(trimmed);
    const isClosing =
      /^(Best regards|Sincerely|Thank you|Regards|Kind regards),/i.test(
        trimmed,
      );
    const isList = /^(\d+\.|[a-z]\.)\s/.test(trimmed);

    if (isGreeting || isClosing) {
      reconstructedParagraphs.push(trimmed);
      continue;
    }

    if (isList) {
      reconstructedParagraphs.push(trimmed);
      continue;
    }

    if (trimmed.length > 400) {
      const sentences = trimmed.match(
        /[^.!?]+[.!?]+(?:\s+[A-Z][^.!?]*[.!?]+)*/g,
      );
      if (sentences && sentences.length > 1) {
        let currentPara = "";
        for (const sentence of sentences) {
          const trimmedSentence = sentence.trim();
          if (!trimmedSentence) continue;

          if (currentPara.length + trimmedSentence.length > 300) {
            if (currentPara.trim()) {
              reconstructedParagraphs.push(currentPara.trim());
            }
            currentPara = trimmedSentence;
          } else {
            currentPara += (currentPara ? " " : "") + trimmedSentence;
          }
        }
        if (currentPara.trim()) {
          reconstructedParagraphs.push(currentPara.trim());
        }
      } else {
        reconstructedParagraphs.push(trimmed);
      }
    } else {
      reconstructedParagraphs.push(trimmed);
    }
  }

  let result = reconstructedParagraphs.join("\n\n");

  result = result.replace(/\n{3,}/g, "\n\n").trim();

  const finalValidation = result
    .split("\n\n")
    .map((p) => p.trim())
    .filter((p) => p.length > 0)
    .join("\n\n");

  return finalValidation;
}

async function buddyPostHandler(req: Request) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return new Response(
        JSON.stringify({
          error: "Unauthorized",
          message: "You must be logged in to use this feature.",
        }),
        {
          status: 401,
          headers: { "Content-Type": "application/json" },
        }
      );
    }

    const aiLimit = checkUserRateLimit(userId, "ai");
    if (!aiLimit.allowed) {
      return new Response(
        JSON.stringify({
          error: "Rate limit exceeded",
          message: "Too many AI requests. Try again later.",
        }),
        {
          status: 429,
          headers: {
            "Content-Type": "application/json",
            "X-RateLimit-Limit": String(aiLimit.limit),
            "X-RateLimit-Remaining": String(aiLimit.remaining),
            "Retry-After": "60",
          },
        },
      );
    }

    const cap = await checkDailyCap(userId, env.AI_DAILY_CAP_TOKENS);
    if (!cap.allowed) {
      const { log: auditLog } = await import("@/lib/audit/audit-log");
      auditLog({ userId, action: "ai_cap_exceeded", metadata: {} });
      return new Response(
        JSON.stringify({
          error: "Daily AI limit reached",
          message: `You have used ${cap.used} of ${cap.limit} tokens today. Try again tomorrow.`,
        }),
        { status: 429, headers: { "Content-Type": "application/json" } },
      );
    }

    let body: ChatRequest;
    try {
      body = await req.json();
    } catch (parseError) {
      console.error("Failed to parse request body:", parseError);
      return new Response(JSON.stringify({ error: "Invalid request body" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const { messages } = body;

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return new Response(
        JSON.stringify({ error: "Messages array is required" }),
        { status: 400, headers: { "Content-Type": "application/json" } },
      );
    }

    const lastMessage = messages[messages.length - 1];
    if (!lastMessage?.content) {
      return new Response(
        JSON.stringify({ error: "No message content provided" }),
        { status: 400, headers: { "Content-Type": "application/json" } },
      );
    }

    if (!env.OPENROUTER_API_KEY) {
      console.error("OPENROUTER_API_KEY is not configured");
      return new Response(
        JSON.stringify({
          error:
            "OpenRouter API key is not configured. Please configure OPENROUTER_API_KEY in your environment variables.",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    const openai = new OpenAI({
      baseURL: "https://openrouter.ai/api/v1",
      apiKey: env.OPENROUTER_API_KEY,
      defaultHeaders: {
        "HTTP-Referer":
          process.env.NEXT_PUBLIC_URL || "https://vectormail.space",
        "X-Title": "VectorMail AI",
      },
    });

    const userMessage = lastMessage.content;
    const isEmail = isEmailRequest(userMessage, messages);
    const isSendRequest = isSendEmailRequest(userMessage);

    if (isSendRequest) {
      const emailAddresses = extractEmailAddresses(userMessage);
      if (emailAddresses.length === 0) {
        return new Response(
          JSON.stringify({
            error: "No email address found",
            message: "Please provide an email address to send to.",
          }),
          { status: 400, headers: { "Content-Type": "application/json" } },
        );
      }

      let lastEmail: { subject: string; body: string } | null = null;
      let extractionError: unknown = null;
      const maxExtractionRetries = 2;

      for (let attempt = 0; attempt <= maxExtractionRetries; attempt++) {
        try {
          lastEmail = await extractEmailFromConversation(messages, openai, { userId });
          if (lastEmail) {
            break;
          }
        } catch (error) {
          extractionError = error;
          if (attempt < maxExtractionRetries) {
            console.log(
              `[BUDDY] Email extraction attempt ${attempt + 1} failed, retrying...`,
            );
            await new Promise((resolve) =>
              setTimeout(resolve, 300 * (attempt + 1)),
            );
          }
        }
      }

      if (!lastEmail) {
        console.error(
          "[BUDDY] Failed to extract email after retries:",
          extractionError,
        );
        return new Response(
          JSON.stringify({
            error: "No email found",
            message:
              "I couldn't find a generated email to send. Please generate an email first, then ask me to send it.",
          }),
          { status: 400, headers: { "Content-Type": "application/json" } },
        );
      }

      const account = await db.account.findFirst({
        where: { userId },
        select: {
          id: true,
          emailAddress: true,
          name: true,
          token: true,
          needsReconnection: true,
          tokenExpiresAt: true,
        },
      });

      if (!account || !account.token) {
        return new Response(
          JSON.stringify({
            error: "No account found",
            message: "Please connect an email account first.",
          }),
          { status: 404, headers: { "Content-Type": "application/json" } },
        );
      }



      if (account.needsReconnection) {
        console.log("[BUDDY] Account needs reconnection - initiating silent reauth");
        return new Response(
          JSON.stringify({
            error: "Authentication expired",
            message: "Your session has expired. Please reconnect your account and try again.",
            needsReconnection: true,
          }),
          { status: 401, headers: { "Content-Type": "application/json" } },
        );
      }

      const enableEmailSend =
        env.ENABLE_EMAIL_SEND ?? process.env.ENABLE_EMAIL_SEND === "true";
      if (!enableEmailSend) {
        return new Response(
          JSON.stringify({
            error: "Email sending is disabled",
            message:
              "Email sending is currently disabled. Please contact support.",
          }),
          { status: 403, headers: { "Content-Type": "application/json" } },
        );
      }

      try {
        const emailAccount = new Account(account.id, account.token);


        console.log("[BUDDY] Validating token before sending email...");
        const isTokenValid = await emailAccount['validateToken']?.() ?? true;
        if (!isTokenValid) {
          console.error("[BUDDY] Token validation failed - marking account for reconnection");
          await db.account.update({
            where: { id: account.id },
            data: { needsReconnection: true },
          }).catch(err => console.error("[BUDDY] Failed to update needsReconnection:", err));

          return new Response(
            JSON.stringify({
              error: "Authentication expired",
              message: "Your session has expired. Please reconnect your account and try again.",
              needsReconnection: true,
            }),
            { status: 401, headers: { "Content-Type": "application/json" } },
          );
        }

        const formattedBody = lastEmail.body
          .split("\n\n")
          .map(
            (para) =>
              `<p style="margin: 0 0 12px 0; line-height: 1.6;">${para.replace(/\n/g, "<br>")}</p>`,
          )
          .join("");

        const watermark = `<div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #e0e0e0; text-align: center; width: 100%;"><div style="color: #999999; font-size: 11px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; display: inline-block; margin: 0 auto;">Generated by VectorMail</div></div>`;
        const emailBodyWithWatermark = formattedBody + watermark;

        const maxRetries = 2;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          try {
            await emailAccount.sendEmail({
              from: {
                address: account.emailAddress,
                name: account.name || account.emailAddress,
              },
              to: emailAddresses.map((email) => ({
                address: email,
                name: email,
              })),
              subject: lastEmail.subject,
              body: emailBodyWithWatermark,
            });

            break;
          } catch (retryError) {
            void retryError;
            if (attempt < maxRetries) {
              await new Promise((resolve) =>
                setTimeout(resolve, 500 * (attempt + 1)),
              );
              console.log(
                `[BUDDY] Email send attempt ${attempt + 1} failed, retrying...`,
              );
            } else {
              throw retryError;
            }
          }
        }

        return new Response(
          JSON.stringify({
            message: `Email sent successfully to ${emailAddresses.join(", ")}!`,
            type: "conversation",
            emailSent: true,
            recipient: emailAddresses[0],
          }),
          {
            headers: {
              "Content-Type": "application/json",
              "Cache-Control": "no-cache",
            },
          },
        );
      } catch (error) {
        console.error("Error sending email:", error);

        let errorMessage = "Unknown error";
        let statusCode = 500;
        let needsReconnection = false;

        if (error instanceof Error) {
          errorMessage = error.message;
          const errorWithStatus = error as unknown as {
            status?: number;
            response?: { status?: number };
          };
          if (errorWithStatus.status) {
            statusCode = errorWithStatus.status;
          }
          if (errorWithStatus.response?.status) {
            statusCode = errorWithStatus.response.status;
          }

          if (errorMessage.includes("Request failed with status code")) {
            const statusMatch = errorMessage.match(/status code (\d+)/);
            if (statusMatch) {
              statusCode = parseInt(statusMatch[1] || "500", 10);
            }
          }


          if (
            statusCode === 401 ||
            errorMessage.toLowerCase().includes("unauthorized") ||
            errorMessage.toLowerCase().includes("authentication") ||
            errorMessage.toLowerCase().includes("invalid token")
          ) {
            needsReconnection = true;
            statusCode = 401;
            errorMessage = "Your session has expired";


            await db.account.update({
              where: { id: account.id },
              data: { needsReconnection: true },
            }).catch(err => console.error("[BUDDY] Failed to update needsReconnection:", err));
          }
        }

        return new Response(
          JSON.stringify({
            error: needsReconnection ? "Authentication expired" : "Failed to send email",
            message: needsReconnection
              ? "Your session has expired. Please reconnect your account and try again."
              : `Could not send the email: ${errorMessage}. Please try again.`,
            details: error instanceof Error ? error.message : undefined,
            needsReconnection,
          }),
          {
            status: statusCode,
            headers: { "Content-Type": "application/json" },
          },
        );
      }
    }

    let systemPrompt: string;
    let userPrompt: string;

    if (isEmail) {
      const previousEmail = messages
        .slice()
        .reverse()
        .find((msg) => msg.role === "assistant" && msg.emailData);

      const isRegeneration = previousEmail !== undefined;

      systemPrompt = `You are a professional AI email assistant that generates complete email drafts based on user summaries.

Your task is to generate a professional email with a clear subject line and well-written body, plus provide 2-3 alternative suggestions.

IMPORTANT: You MUST respond with ONLY valid JSON. No markdown, no code blocks, no explanations - just pure JSON.

The JSON structure must be:
{
  "subject": "Email subject line here",
  "body": "Complete email body with proper greeting, content, and closing",
  "suggestions": [
    {
      "subject": "Alternative subject 1",
      "body": "Alternative email body 1"
    },
    {
      "subject": "Alternative subject 2", 
      "body": "Alternative email body 2"
    }
  ]
}

ðŸš¨ðŸš¨ðŸš¨ CRITICAL FORMATTING RULES - YOU MUST FOLLOW THESE EXACTLY - NO EXCEPTIONS ðŸš¨ðŸš¨ðŸš¨

PARAGRAPH SPACING (MOST IMPORTANT - THIS IS MANDATORY - VIOLATION WILL BREAK THE EMAIL):
- EVERY paragraph MUST be separated by EXACTLY \\n\\n (double newline) - NO EXCEPTIONS
- NEVER use single \\n between paragraphs - ALWAYS use \\n\\n - THIS IS CRITICAL
- NEVER combine multiple paragraphs into one - EACH paragraph must be on separate lines with \\n\\n between them
- After greeting: ALWAYS use \\n\\n before first paragraph - MANDATORY
- Before closing: ALWAYS use \\n\\n after last paragraph - MANDATORY
- Between EVERY paragraph: ALWAYS use \\n\\n - THIS IS NOT OPTIONAL
- If you write multiple sentences that form separate thoughts, they MUST be in separate paragraphs with \\n\\n between them
- If a sentence ends with . ! or ? and the next sentence starts with a capital letter, you MUST use \\n\\n between them
- DO NOT use single \\n anywhere between paragraphs - ONLY use \\n\\n

LIST FORMATTING (CRITICAL - MUST FOLLOW EXACTLY):
- ALWAYS add \\n\\n before lists
- ALWAYS add \\n\\n after lists
- âš ï¸âš ï¸âš ï¸ ABSOLUTELY CRITICAL: Each numbered list item MUST have the number, period, space, and text ALL on ONE SINGLE LINE
- Format: "1. Text content here" - ALL on the same line with NO line breaks between number and text
- NEVER put a line break (\\n) between the number and the text
- NEVER put a blank line (\\n\\n) between the number and the text
- Each complete list item (number + text) goes on its own line
- Example CORRECT: "1. First achievement\\n2. Second achievement\\n3. Third achievement"
- Example WRONG: "1.\\nFirst achievement" or "1.\\n\\nFirst achievement"
- Use ONLY numbers (1., 2., 3.) or letters (a., b., c.)
- NO symbols ever

SECTION HEADINGS:
- If you use section headings, add \\n\\n before heading and \\n\\n after heading

FORMATTING RULES - NO SYMBOLS ALLOWED:
- FORBIDDEN: Do NOT use ANY symbols - NO asterisks (*), NO double asterisks (**), NO triple asterisks (***), NO dashes (-), NO dots (â€¢), NO special characters
- For lists, use ONLY numbers (1., 2., 3.) or letters (a., b., c.) - NO symbols
- NEVER use asterisks (*), dashes (-), dots (â€¢), or any other symbols for lists or emphasis
- Keep formatting clean and professional with plain text only - NO markdown symbols at all

CORRECT FORMAT EXAMPLE (COPY THIS STRUCTURE - NOTE: Numbers and text on SAME line):
Dear [Name],\\n\\nThank you for meeting with me. I wanted to follow up on our discussion.\\n\\n1. First key point\\na. Sub-point with details\\nb. Another sub-point\\n2. Second key point\\na. Sub-point details\\n3. Third key point\\n\\nNext Steps:\\n\\n1. Action item one\\n2. Action item two\\n3. Action item three\\n\\nBest regards,\\n[Your name]

WRONG FORMAT (NEVER DO THIS):
1.\\nFirst key point
1.\\n\\nFirst key point
2.\\nSecond key point

CORRECT FORMAT (ALWAYS DO THIS):
1. First key point\\n2. Second key point\\n3. Third key point

ABSOLUTELY FORBIDDEN - DO NOT USE:
* Asterisks
- Dashes
â€¢ Dots
Any symbols at all

GUIDELINES:
- Write professional, clear, and concise emails
- Use appropriate greetings (Dear, Hi, Hello) and closings (Best regards, Sincerely, Thank you)
- Make the subject line specific and actionable
- Ensure the body is well-structured with proper paragraphs and spacing
- Use proper line breaks and spacing for readability
- Suggestions should offer different tones (formal/casual) or approaches
- Return ONLY the JSON object, nothing else`;

      if (isRegeneration) {
        const previousEmailContext = previousEmail?.emailData
          ? `Previous email subject: ${previousEmail.emailData.subject}\nPrevious email body (for reference only): ${previousEmail.emailData.body.substring(0, 500)}...`
          : "";

        const wantsLongerEmail =
          /(more explanatory|more detailed|expand|bigger|longer|lengthy|comprehensive|elaborate|extend)/i.test(
            userMessage,
          );

        userPrompt = `The user wants a ${wantsLongerEmail ? "longer, more detailed, and more comprehensive" : userMessage.toLowerCase().includes("better") ? "better" : "different"} version of a previously generated email. Generate a new, improved email with better formatting, structure, and content. ${wantsLongerEmail ? "Make it significantly longer with more detailed explanations, additional context, and comprehensive coverage of all topics." : ""} Return ONLY valid JSON in the exact format specified.

${previousEmailContext ? `\n${previousEmailContext}\n` : ""}
âš ï¸âš ï¸âš ï¸ CRITICAL FORMATTING REQUIREMENTS - MUST FOLLOW EXACTLY - NO EXCEPTIONS (ESPECIALLY FOR LONGER EMAILS) âš ï¸âš ï¸âš ï¸:
1. ALWAYS use \\n\\n (double newline) between paragraphs - this is MANDATORY - NEVER use single \\n
2. NEVER use single \\n between paragraphs - ALWAYS use \\n\\n - THIS WILL BREAK THE EMAIL
3. ALWAYS add \\n\\n before lists and \\n\\n after lists for proper spacing
4. âš ï¸âš ï¸âš ï¸ ABSOLUTELY CRITICAL - NUMBERED LIST FORMATTING âš ï¸âš ï¸âš ï¸:
   - The number, period, space, and text MUST ALL be on ONE SINGLE LINE
   - Format: "1. Text content here" - ALL on the same line with NO line breaks
   - NEVER put a line break (\\n) between the number and the text
   - NEVER put a blank line (\\n\\n) between the number and the text
   - Each complete list item (number + text) goes on its own line
   - Example CORRECT: "1. First achievement\\n2. Second achievement\\n3. Third achievement"
   - Example WRONG: "1.\\nFirst achievement" or "1.\\n\\nFirst achievement" or "1.\\nFirst achievement"
5. ALWAYS use proper spacing: blank line before sections, blank line after sections
6. NEVER use symbols - only numbers (1., 2., 3.) or letters (a., b., c.) for lists
7. NEVER combine paragraphs - each paragraph must be separated by \\n\\n - THIS IS CRITICAL
8. If a sentence ends with . ! or ? and next starts with capital letter, use \\n\\n between them
9. FOR LONGER EMAILS: Break content into clear sections with proper headings and spacing
10. FOR LONGER EMAILS: Each section should be separated by \\n\\n before the section heading and \\n\\n after the section content
11. FOR LONGER EMAILS: Maintain consistent structure - greeting, introduction, main sections, conclusion, closing
12. DO NOT use single \\n anywhere between paragraphs - ONLY use \\n\\n

FORMAT EXAMPLE FOR LONGER EMAILS (copy this structure exactly - note numbers and text on same line, NO line break):
Dear [Name],\\n\\n[Opening paragraph]\\n\\n[Section Heading 1]\\n\\n[Detailed paragraph about section 1]\\n\\n[Sub-points or details]\\n\\n1. First main point\\na. Detailed explanation\\nb. Additional context\\n2. Second main point\\na. Detailed explanation\\n3. Third main point\\n\\n[Section Heading 2]\\n\\n[Detailed paragraph about section 2]\\n\\n[More content]\\n\\n[Section Heading 3]\\n\\n[Detailed paragraph]\\n\\n[Conclusion paragraph]\\n\\nBest regards,\\n[Name]

ABSOLUTELY FORBIDDEN - NEVER DO THIS (WRONG):
1.\\nText here
1.\\n\\nText here
2.\\nMore text
2.\\n\\nMore text

MANDATORY FORMAT (CORRECT - DO THIS):
1. Text here\\n2. More text\\n3. Even more text

User request: ${userMessage}`;
      } else {
        userPrompt = `Generate an email based on this summary. Return ONLY valid JSON in the exact format specified.

ðŸš¨ðŸš¨ðŸš¨ CRITICAL FORMATTING REQUIREMENTS - MUST FOLLOW EXACTLY - NO EXCEPTIONS ðŸš¨ðŸš¨ðŸš¨:
1. ALWAYS use \\n\\n (double newline) between EVERY paragraph - this is MANDATORY - NEVER use single \\n
2. NEVER use single \\n between paragraphs - ALWAYS use \\n\\n - THIS WILL BREAK THE EMAIL IF YOU DON'T
3. ALWAYS add \\n\\n before lists and \\n\\n after lists
4. âš ï¸âš ï¸âš ï¸ ABSOLUTELY CRITICAL - NUMBERED LIST FORMATTING âš ï¸âš ï¸âš ï¸:
   - The number, period, space, and text MUST ALL be on ONE SINGLE LINE
   - Format: "1. Text content here" - ALL on the same line
   - NEVER put a line break (\\n) between the number and the text
   - NEVER put a blank line between the number and the text
   - Each complete list item (number + text) goes on its own line
   - Example CORRECT: "1. First achievement\\n2. Second achievement\\n3. Third achievement"
   - Example WRONG: "1.\\nFirst achievement" or "1.\\n\\nFirst achievement"
5. NO symbols - use only numbers (1., 2., 3.) or letters (a., b., c.) for lists
6. Use plain text formatting only
7. After greeting, use \\n\\n before first paragraph - MANDATORY
8. Before closing, use \\n\\n after last paragraph - MANDATORY
9. If a sentence ends with . ! or ? and next starts with capital letter, use \\n\\n between them
10. DO NOT combine paragraphs - each paragraph MUST be separated by \\n\\n

FORMAT EXAMPLE (CORRECT - number and text on same line, NO line break between them):
Dear [Name],\\n\\n[First paragraph]\\n\\n[Second paragraph]\\n\\n1. First item\\n2. Second item\\n3. Third item\\n\\n[Third paragraph]\\n\\nBest regards,\\n[Name]

ABSOLUTELY FORBIDDEN - NEVER DO THIS (WRONG):
1.\\nText here
1.\\n\\nText here
2.\\nMore text

MANDATORY FORMAT (CORRECT - DO THIS):
1. Text here\\n2. More text\\n3. Even more text

Summary: ${userMessage}`;
      }
    } else {
      systemPrompt = `You are AI Buddy, a helpful, friendly, and knowledgeable AI assistant. You can help with a wide variety of tasks and questions.

YOUR CAPABILITIES:
1. Casual Chat: Engage in friendly, natural conversations
2. Email Generation: Help compose, draft, and write professional emails
3. Suggestions & Advice: Provide recommendations, tips, and suggestions on various topics
4. General Questions: Answer questions about meetings, schedules, calendars, work, life, technology, science, history, and any other topic
5. Problem Solving: Help solve problems, brainstorm ideas, and think through challenges
6. Explanations: Explain concepts, how things work, and provide tutorials
7. Coding Help: Assist with programming, debugging, and technical questions
8. Content Writing: Help write, edit, and improve written content

CRITICAL INSTRUCTIONS FOR ACCURATE RESPONSES:
1. ALWAYS answer the specific question asked - provide helpful, relevant information
2. Read the user's question carefully and understand exactly what they're asking
3. Provide direct, clear answers that directly address the question
4. For questions about meetings, schedules, or calendars: Provide helpful information about how to manage meetings, best practices for scheduling, or general advice (even if you don't have access to their specific calendar)
5. For email-related questions: Offer to help generate emails or provide email writing advice
6. For general knowledge questions: Answer accurately based on your knowledge
7. If the question is unclear, ask for clarification rather than guessing
8. Maintain conversation context from previous messages when relevant
9. Be helpful, friendly, and conversational - engage naturally with the user
10. DO NOT refuse to answer questions - always try to be helpful, even if you need to explain limitations

IMPORTANT FORMATTING RULES - NO SYMBOLS ALLOWED:
- FORBIDDEN: Do NOT use ANY symbols - NO asterisks (*), NO double asterisks (**), NO triple asterisks (***), NO dashes (-), NO dots (â€¢), NO special characters
- For lists, use ONLY numbers (1., 2., 3.) or letters (a., b., c.) - NO symbols
- NEVER use asterisks (*), dashes (-), dots (â€¢), or any other symbols for lists or emphasis
- Use plain text formatting only - NO markdown symbols at all
- Keep formatting clean and professional with plain text only

SPECIFIC QUESTION HANDLING:
- Questions about meetings/schedules: Provide helpful information about meeting management, scheduling best practices, or suggest checking their email/calendar. Be helpful and informative.
- Questions about emails: Offer to help generate, draft, or improve emails
- General knowledge questions: Answer accurately and thoroughly
- Casual conversation: Engage naturally and be friendly
- Requests for suggestions: Provide thoughtful, practical suggestions

Remember: Your goal is to be helpful and answer questions. Always try to provide value, even if you need to explain limitations or suggest alternatives. Be accurate, helpful, and stay on topic.`;

      userPrompt = userMessage;
    }

    const wantsLongerEmail =
      isEmail &&
      /(more explanatory|more detailed|expand|bigger|longer|lengthy|comprehensive|elaborate|extend)/i.test(
        userMessage,
      );
    const maxTokens = wantsLongerEmail ? 3000 : isEmail ? 2000 : 2000;

    let completion;
    try {
      const completionMessages = isEmail
        ? [
          { role: "system" as const, content: systemPrompt },
          { role: "user" as const, content: userPrompt },
        ]
        : (() => {
          const conversationMessages = messages
            .filter((msg) => msg.role !== "system")
            .map((msg) => ({
              role: msg.role as "user" | "assistant",
              content: msg.content,
            }));

          return [
            { role: "system" as const, content: systemPrompt },
            ...conversationMessages,
          ];
        })();

      let model = "anthropic/claude-3.5-sonnet";

      try {
        completion = await openai.chat.completions.create({
          model: model,
          messages: completionMessages,
          max_tokens: maxTokens,
          temperature: isEmail ? 0.7 : 0.3,
          ...(isEmail && { response_format: { type: "json_object" } }),
        });
      } catch (primaryError) {
        console.warn(
          "Primary model (Claude 3.5 Sonnet) failed, trying GPT-4o-mini:",
          primaryError,
        );
        try {
          model = "openai/gpt-4o-mini";
          completion = await openai.chat.completions.create({
            model: model,
            messages: completionMessages,
            max_tokens: maxTokens,
            temperature: isEmail ? 0.7 : 0.3,
            ...(isEmail && { response_format: { type: "json_object" } }),
          });
        } catch (secondaryError) {
          console.warn(
            "Secondary model failed, trying Gemini:",
            secondaryError,
          );
          model = "google/gemini-2.5-flash";
          completion = await openai.chat.completions.create({
            model: model,
            messages: completionMessages,
            max_tokens: maxTokens,
            temperature: isEmail ? 0.7 : 0.3,
            ...(isEmail && { response_format: { type: "json_object" } }),
          });
        }
      }
    } catch (apiError) {
      console.error("OpenRouter API error:", apiError);
      const errorMessage =
        apiError instanceof Error
          ? apiError.message
          : "Failed to create chat completion";
      return new Response(
        JSON.stringify({
          error: "Failed to connect to AI service",
          details: errorMessage,
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    if (!completion || !completion.choices || completion.choices.length === 0) {
      console.error("Invalid completion response:", completion);
      return new Response(
        JSON.stringify({
          error: "Invalid AI response",
          details:
            "The AI service returned an empty or invalid response. Please try again.",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    const content = completion.choices[0]?.message?.content || "";

    const usage = completion.usage;
    recordUsage({
      userId,
      operation: "buddy",
      inputTokens: usage?.prompt_tokens ?? 0,
      outputTokens: usage?.completion_tokens ?? 0,
      model: completion.model ?? undefined,
    });

    if (!content || content.trim() === "") {
      console.error("Empty content in AI response");
      return new Response(
        JSON.stringify({
          error: "Empty AI response",
          details:
            "The AI service returned an empty response. Please try again.",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    if (isEmail) {
      let emailData;
      try {
        emailData = JSON.parse(content);
      } catch (parseError) {
        console.error("Failed to parse AI response directly:", parseError);
        console.error("AI response content:", content.substring(0, 500));

        const jsonMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          try {
            emailData = JSON.parse(jsonMatch[1]);
          } catch {
            const jsonObjectMatch = content.match(/\{[\s\S]*\}/);
            if (jsonObjectMatch && jsonObjectMatch[0]) {
              try {
                emailData = JSON.parse(jsonObjectMatch[0]);
              } catch {
                console.error(
                  "Failed to parse extracted JSON:",
                  jsonObjectMatch[0].substring(0, 200),
                );
                return new Response(
                  JSON.stringify({
                    error: "Failed to parse AI response",
                    details:
                      "The AI returned an invalid JSON format. Please try again.",
                    rawContent: content.substring(0, 200),
                  }),
                  {
                    status: 500,
                    headers: { "Content-Type": "application/json" },
                  },
                );
              }
            } else {
              return new Response(
                JSON.stringify({
                  error: "Failed to parse AI response",
                  details:
                    "The AI returned an invalid format. Please try again.",
                  rawContent: content.substring(0, 200),
                }),
                {
                  status: 500,
                  headers: { "Content-Type": "application/json" },
                },
              );
            }
          }
        } else {
          const jsonObjectMatch = content.match(/\{[\s\S]*\}/);
          if (jsonObjectMatch && jsonObjectMatch[0]) {
            try {
              emailData = JSON.parse(jsonObjectMatch[0]);
            } catch {
              return new Response(
                JSON.stringify({
                  error: "Failed to parse AI response",
                  details:
                    "The AI returned an invalid JSON format. Please try again.",
                  rawContent: content.substring(0, 200),
                }),
                {
                  status: 500,
                  headers: { "Content-Type": "application/json" },
                },
              );
            }
          } else {
            return new Response(
              JSON.stringify({
                error: "Failed to parse AI response",
                details: "The AI did not return valid JSON. Please try again.",
                rawContent: content.substring(0, 200),
              }),
              { status: 500, headers: { "Content-Type": "application/json" } },
            );
          }
        }
      }

      if (!emailData || typeof emailData !== "object") {
        return new Response(
          JSON.stringify({
            error: "Invalid email structure",
            details: "The AI response is not a valid object. Please try again.",
          }),
          { status: 500, headers: { "Content-Type": "application/json" } },
        );
      }

      if (!emailData.subject || !emailData.body) {
        return new Response(
          JSON.stringify({
            error: "Invalid email structure",
            details: `The AI response is missing required fields. Subject: ${!!emailData.subject}, Body: ${!!emailData.body}. Please try again.`,
          }),
          { status: 500, headers: { "Content-Type": "application/json" } },
        );
      }

      emailData.body = removeAllSymbols(emailData.body);

      const originalBody = emailData.body.trim();
      const sentenceCount = (originalBody.match(/[.!?]+/g) || []).length;
      const hasMultipleSentences = sentenceCount > 1;
      const isLongText = originalBody.length > 150;

      if (hasMultipleSentences || isLongText) {
        const paragraphs: string[] = [];
        let processedText = originalBody;

        const greetingPatterns = [
          /^((?:Dear|Hi|Hello)\s+[^,]+,\s*)/i,
          /^([A-Z][a-z]+,\s*)/,
        ];

        let greetingFound = false;
        for (const pattern of greetingPatterns) {
          const greetingMatch = processedText.match(pattern);
          if (greetingMatch) {
            paragraphs.push(greetingMatch[0].trim());
            processedText = processedText
              .substring(greetingMatch[0].length)
              .trim();
            greetingFound = true;
            break;
          }
        }

        let closing = "";
        const closingPatterns = [
          /(Best regards|Sincerely|Thank you|Regards|Kind regards),?\s*[A-Z][a-z\s]*$/i,
          /(Best regards|Sincerely|Thank you|Regards|Kind regards),/i,
        ];

        for (const pattern of closingPatterns) {
          const closingMatch = processedText.match(pattern);
          if (closingMatch) {
            closing = closingMatch[0].trim();
            processedText = processedText
              .substring(0, processedText.length - closingMatch[0].length)
              .trim();
            break;
          }
        }

        let sentences: string[] = [];

        sentences = processedText.match(/[^.!?]+[.!?]+(?:\s+|$)/g) || [];

        if (sentences.length === 0) {
          sentences = processedText.match(/[^.!?]+[.!?]+/g) || [];
        }

        if (sentences.length === 0) {
          const manualSplit = processedText.split(/([.!?]+\s+)/);
          for (let i = 0; i < manualSplit.length; i += 2) {
            const sentence =
              (manualSplit[i] || "") + (manualSplit[i + 1] || "");
            if (sentence.trim() && sentence.trim().length > 5) {
              sentences.push(sentence.trim());
            }
          }
        }

        if (sentences.length === 0 && sentenceCount > 0) {
          const parts = processedText.split(/([.!?]+)/);
          let currentSentence = "";
          for (let i = 0; i < parts.length; i++) {
            currentSentence += parts[i] || "";
            if (parts[i]?.match(/[.!?]+/)) {
              if (currentSentence.trim()) {
                sentences.push(currentSentence.trim());
              }
              currentSentence = "";
            }
          }
          if (currentSentence.trim()) {
            sentences.push(currentSentence.trim());
          }
        }

        if (sentences.length === 0) {
          sentences = [processedText];
        }

        let currentPara = "";
        for (const sentence of sentences) {
          const trimmed = sentence.trim();
          if (!trimmed || trimmed.length < 3) continue;

          const currentSentenceCount = (currentPara.match(/[.!?]+/g) || [])
            .length;
          const wouldExceedLength = currentPara.length + trimmed.length > 250;

          if (
            currentSentenceCount >= 2 ||
            (wouldExceedLength && currentPara.length > 0) ||
            currentPara.length > 200
          ) {
            if (currentPara.trim()) {
              paragraphs.push(currentPara.trim());
            }
            currentPara = trimmed;
          } else {
            currentPara += (currentPara ? " " : "") + trimmed;
          }
        }

        if (currentPara.trim()) {
          paragraphs.push(currentPara.trim());
        }

        if (closing) {
          paragraphs.push(closing);
        }

        if (paragraphs.length === 2 && greetingFound && closing) {
          const mainContent = processedText.trim();
          if (mainContent) {
            paragraphs.splice(1, 0, mainContent);
          }
        }

        emailData.body = paragraphs.join("\n\n");
      } else {
        emailData.body = normalizeEmailFormatting(emailData.body);
        emailData.body = enforceEmailFormatting(emailData.body);
      }

      emailData.body = emailData.body.replace(
        /([.!?])\s*\n([A-Z][a-z])/g,
        "$1\n\n$2",
      );
      emailData.body = emailData.body.replace(
        /([a-z0-9])\s*\n([A-Z][a-z])/g,
        "$1\n\n$2",
      );
      emailData.body = emailData.body.replace(
        /([a-z])\s*\n([A-Z])/g,
        "$1\n\n$2",
      );

      const finalParagraphs = emailData.body
        .split(/\n\n+/)
        .filter((p: string) => p.trim());
      if (finalParagraphs.length === 1) {
        const singlePara = finalParagraphs[0] || "";
        const paraSentenceCount = (singlePara.match(/[.!?]+/g) || []).length;
        if (paraSentenceCount > 1) {
          const sentences = singlePara.match(/[^.!?]+[.!?]+/g) || [];
          if (sentences.length > 1) {
            const newParagraphs: string[] = [];
            let currentPara = "";
            for (const sentence of sentences) {
              const trimmed = sentence.trim();
              if (!trimmed) continue;
              const currentSentenceCount = (currentPara.match(/[.!?]+/g) || [])
                .length;
              if (
                currentSentenceCount >= 2 ||
                currentPara.length + trimmed.length > 250
              ) {
                if (currentPara.trim()) newParagraphs.push(currentPara.trim());
                currentPara = trimmed;
              } else {
                currentPara += (currentPara ? " " : "") + trimmed;
              }
            }
            if (currentPara.trim()) newParagraphs.push(currentPara.trim());
            emailData.body = newParagraphs.join("\n\n");
          }
        }
      }

      emailData.body = emailData.body.replace(/\n{3,}/g, "\n\n").trim();
      emailData.body = emailData.body.replace(
        /^(\d+\.)\s*\n+\s*([^\n\d])/gm,
        "$1 $2",
      );
      emailData.body = emailData.body.replace(
        /^([a-z]\.)\s*\n+\s*([^\n])/gm,
        "$1 $2",
      );
      emailData.body = emailData.body.replace(
        /(\n)(\d+\.)\s*\n([^\n\d])/g,
        "$1$2 $3",
      );
      emailData.body = emailData.body.replace(
        /(\n)([a-z]\.)\s*\n([^\n])/g,
        "$1$2 $3",
      );

      if (emailData.suggestions && Array.isArray(emailData.suggestions)) {
        emailData.suggestions = emailData.suggestions.map(
          (suggestion: { subject: string; body: string }) => {
            let body = removeAllSymbols(suggestion.body);

            const originalBody = body.trim();
            const sentenceCount = (originalBody.match(/[.!?]+/g) || []).length;
            const hasMultipleSentences = sentenceCount > 1;
            const isLongText = originalBody.length > 150;

            if (hasMultipleSentences || isLongText) {
              const paragraphs: string[] = [];
              let processedText = originalBody;

              const greetingPatterns = [
                /^((?:Dear|Hi|Hello)\s+[^,]+,\s*)/i,
                /^([A-Z][a-z]+,\s*)/,
              ];

              let greetingFound = false;
              for (const pattern of greetingPatterns) {
                const greetingMatch = processedText.match(pattern);
                if (greetingMatch) {
                  paragraphs.push(greetingMatch[0].trim());
                  processedText = processedText
                    .substring(greetingMatch[0].length)
                    .trim();
                  greetingFound = true;
                  break;
                }
              }

              let closing = "";
              const closingPatterns = [
                /(Best regards|Sincerely|Thank you|Regards|Kind regards),?\s*[A-Z][a-z\s]*$/i,
                /(Best regards|Sincerely|Thank you|Regards|Kind regards),/i,
              ];

              for (const pattern of closingPatterns) {
                const closingMatch = processedText.match(pattern);
                if (closingMatch) {
                  closing = closingMatch[0].trim();
                  processedText = processedText
                    .substring(0, processedText.length - closingMatch[0].length)
                    .trim();
                  break;
                }
              }

              let sentences: string[] = [];

              sentences = processedText.match(/[^.!?]+[.!?]+(?:\s+|$)/g) || [];

              if (sentences.length === 0) {
                sentences = processedText.match(/[^.!?]+[.!?]+/g) || [];
              }

              if (sentences.length === 0) {
                const manualSplit = processedText.split(/([.!?]+\s+)/);
                for (let i = 0; i < manualSplit.length; i += 2) {
                  const sentence =
                    (manualSplit[i] || "") + (manualSplit[i + 1] || "");
                  if (sentence.trim() && sentence.trim().length > 5) {
                    sentences.push(sentence.trim());
                  }
                }
              }

              if (sentences.length === 0 && sentenceCount > 0) {
                const parts = processedText.split(/([.!?]+)/);
                let currentSentence = "";
                for (let i = 0; i < parts.length; i++) {
                  currentSentence += parts[i] || "";
                  if (parts[i]?.match(/[.!?]+/)) {
                    if (currentSentence.trim()) {
                      sentences.push(currentSentence.trim());
                    }
                    currentSentence = "";
                  }
                }
                if (currentSentence.trim()) {
                  sentences.push(currentSentence.trim());
                }
              }

              if (sentences.length === 0) {
                sentences = [processedText];
              }

              let currentPara = "";
              for (const sentence of sentences) {
                const trimmed = sentence.trim();
                if (!trimmed || trimmed.length < 3) continue;

                const currentSentenceCount = (
                  currentPara.match(/[.!?]+/g) || []
                ).length;
                const wouldExceedLength =
                  currentPara.length + trimmed.length > 250;

                if (
                  currentSentenceCount >= 2 ||
                  (wouldExceedLength && currentPara.length > 0) ||
                  currentPara.length > 200
                ) {
                  if (currentPara.trim()) {
                    paragraphs.push(currentPara.trim());
                  }
                  currentPara = trimmed;
                } else {
                  currentPara += (currentPara ? " " : "") + trimmed;
                }
              }

              if (currentPara.trim()) {
                paragraphs.push(currentPara.trim());
              }

              if (closing) {
                paragraphs.push(closing);
              }

              if (paragraphs.length === 2 && greetingFound && closing) {
                const mainContent = processedText.trim();
                if (mainContent) {
                  paragraphs.splice(1, 0, mainContent);
                }
              }

              body = paragraphs.join("\n\n");
            } else {
              body = normalizeEmailFormatting(body);
              body = enforceEmailFormatting(body);
            }

            body = body.replace(/([.!?])\s*\n([A-Z][a-z])/g, "$1\n\n$2");
            body = body.replace(/([a-z0-9])\s*\n([A-Z][a-z])/g, "$1\n\n$2");

            return {
              subject: suggestion.subject,
              body: body,
            };
          },
        );
      }

      return new Response(JSON.stringify(emailData), {
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache",
        },
      });
    } else {
      const cleanedContent = removeAllSymbols(content);

      return new Response(
        JSON.stringify({
          message: cleanedContent,
          type: "conversation",
        }),
        {
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-cache",
          },
        },
      );
    }
  } catch (error) {
    console.error("Buddy chat error:", error);

    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    return new Response(
      JSON.stringify({
        error: "Failed to process chat request",
        details: errorMessage,
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      },
    );
  }
}

export const POST = withRequestId(buddyPostHandler);
