import { auth } from "@clerk/nextjs/server";
import OpenAI from "openai";
import { env } from "@/env.js";
import { db } from "@/server/db";
import { Account } from "@/lib/accounts";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

interface ChatRequest {
  messages: Array<{
    role: "user" | "assistant" | "system";
    content: string;
    emailData?: {
      subject: string;
      body: string;
      suggestions?: Array<{ subject: string; body: string }>;
    };
  }>;
}

function isEmailRequest(
  message: string,
  previousMessages?: Array<{
    role: string;
    emailData?: { subject: string; body: string };
  }>,
): boolean {
  const emailKeywords = [
    "email",
    "mail",
    "write an email",
    "write a mail",
    "make an email",
    "make a mail",
    "generate an email",
    "generate a mail",
    "create an email",
    "create a mail",
    "compose",
    "draft",
    "send",
    "subject",
    "follow up",
    "follow-up",
    "thank you",
    "thank you note",
    "meeting",
    "introduction",
    "intro",
    "request",
    "reply",
    "response",
    "cold mail",
    "cold email",
    "outreach",
    "proposal",
    "status update",
    "update",
    "hire",
    "hiring",
    "job",
    "application",
    "cover letter",
  ];
  const lowerMessage = message.toLowerCase();

  if (emailKeywords.some((keyword) => lowerMessage.includes(keyword))) {
    return true;
  }

  if (/make\s+(me\s+)?(a|an|one)\s+.*\s+(mail|email)/i.test(message)) {
    return true;
  }

  if (/can\s+you\s+.*\s+(mail|email)/i.test(message)) {
    return true;
  }

  if (previousMessages && previousMessages.length > 0) {
    const hasPreviousEmail = previousMessages.some(
      (msg) => msg.role === "assistant" && msg.emailData,
    );

    if (hasPreviousEmail) {
      const regenerationKeywords = [
        "better",
        "improve",
        "regenerate",
        "another",
        "different",
        "change",
        "redo",
        "revise",
        "update",
        "modify",
        "edit",
        "rewrite",
        "new version",
        "another version",
        "different version",
        "more explanatory",
        "more detailed",
        "expand",
        "bigger",
        "longer",
        "lengthy",
        "comprehensive",
        "elaborate",
        "extend",
      ];

      if (
        regenerationKeywords.some((keyword) => lowerMessage.includes(keyword))
      ) {
        return true;
      }
    }
  }

  return false;
}

function extractEmailAddresses(text: string): string[] {
  const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
  const matches = text.match(emailRegex);
  return matches || [];
}

function isSendEmailRequest(message: string): boolean {
  const lowerMessage = message.toLowerCase();
  const sendKeywords = [
    "send",
    "send this",
    "send it",
    "send the email",
    "send that",
    "send to",
    "send this email",
    "send that email",
    "send it to",
    "send this to",
    "send that to",
    "can you send",
    "please send",
    "send the",
  ];
  const hasEmail = extractEmailAddresses(message).length > 0;

  const hasSendKeyword = sendKeywords.some((keyword) =>
    lowerMessage.includes(keyword),
  );
  return hasEmail && hasSendKeyword;
}

async function extractEmailFromConversation(
  messages: Array<{
    role: string;
    content: string;
    emailData?: { subject: string; body: string };
  }>,
  openai: OpenAI,
): Promise<{ subject: string; body: string } | null> {
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i];
    if (
      msg &&
      msg.role === "assistant" &&
      msg.emailData &&
      msg.emailData.subject &&
      msg.emailData.body
    ) {
      return {
        subject: msg.emailData.subject,
        body: msg.emailData.body,
      };
    }
  }

  const conversationContext = messages
    .slice(-20)
    .map((msg) => {
      if (!msg) return "";
      let content = `${msg.role}: ${msg.content}`;

      if (msg.emailData) {
        content += `\n[Email Data Available]\nSubject: ${msg.emailData.subject}\nBody: ${msg.emailData.body}`;
      }
      return content;
    })
    .filter((content) => content !== "")
    .join("\n\n");

  const extractionPrompt = `Based on the conversation below, extract the MOST RECENT email that was generated. Look for the subject line and complete email body that was created by the assistant.

IMPORTANT: 
- Look for the most recent email generation in the conversation
- The email should have been generated by the assistant in response to a user request
- Extract the complete subject and body text
- If the conversation shows "Here's your draft:" or similar, the email details should follow

Return ONLY valid JSON in this exact format:
{
  "subject": "Email subject here",
  "body": "Complete email body here"
}

If no email can be found, return: {"subject": null, "body": null}

Conversation:
${conversationContext}`;

  try {
    const completion = await openai.chat.completions.create({
      model: "anthropic/claude-3-haiku",
      messages: [
        {
          role: "system",
          content:
            "You are a helpful assistant that extracts email information from conversations. You must find the most recently generated email with both subject and body. Return ONLY valid JSON, no other text.",
        },
        {
          role: "user",
          content: extractionPrompt,
        },
      ],
      max_tokens: 2000,
      temperature: 0.1,
      response_format: { type: "json_object" },
    });

    const content = completion.choices[0]?.message?.content || "";
    try {
      const parsed = JSON.parse(content);
      if (
        parsed.subject &&
        parsed.body &&
        parsed.subject !== "null" &&
        parsed.body !== "null" &&
        parsed.subject.trim() !== "" &&
        parsed.body.trim() !== ""
      ) {
        return { subject: parsed.subject, body: parsed.body };
      }
    } catch {}
  } catch (error) {
    console.error("Error extracting email from conversation:", error);
  }

  return null;
}

function removeAllSymbols(text: string): string {
  text = text.replace(/\*+/g, "");

  text = text.replace(/^\s*-\s+/gm, "");

  text = text.replace(/‚Ä¢/g, "");

  text = text.replace(/^\s*[‚ñ™‚ñ´‚ó¶‚Ä£‚ÅÉ]\s+/gm, "");

  text = text.replace(/\n\s*\n\s*\n/g, "\n\n");

  return text;
}

function normalizeEmailFormatting(text: string): string {
  if (!text || typeof text !== "string") return text;

  text = text.replace(/[ \t]+$/gm, "");

  text = text.replace(/\n{3,}/g, "\n\n");

  text = text.replace(/([.!?])\s*\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/([a-z]),\s*\n([A-Z][a-z])/g, "$1,\n\n$2");

  text = text.replace(/([^\n])\n(\d+\.\s)/g, "$1\n\n$2");

  text = text.replace(/([^\n])\n([a-z]\.\s)/g, "$1\n\n$2");

  text = text.replace(/([a-z0-9]\.\s[^\n]+)\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(
    /([^\n])\n([A-Z][A-Za-z\s]{2,40})\n([A-Z][a-z])/g,
    "$1\n\n$2\n\n$3",
  );

  text = text.replace(/([A-Z][A-Za-z\s]{2,40})\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/(\d+\.\s[A-Z][^\n]+)\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/([a-z.!?])\s*\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/(Dear [^,]+,\s*)\n([A-Z])/g, "$1\n\n$2");
  text = text.replace(/(Hi [^,]+,\s*)\n([A-Z])/g, "$1\n\n$2");
  text = text.replace(/(Hello [^,]+,\s*)\n([A-Z])/g, "$1\n\n$2");

  text = text.replace(
    /([^\n])\n(Best regards|Sincerely|Thank you|Regards|Kind regards),/g,
    "$1\n\n$2,",
  );

  text = text.replace(/([a-z0-9.!?])\n([A-Z][a-z])/g, "$1\n\n$2");

  text = text.replace(/\n{1}\n{1,}/g, "\n\n");

  text = text.trim();

  const paragraphs: string[] = [];
  const lines = text.split("\n");
  let currentParagraph = "";
  let inList = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]?.trim() || "";
    const nextLine = lines[i + 1]?.trim() || "";

    if (!line) {
      if (currentParagraph.trim()) {
        paragraphs.push(currentParagraph.trim());
        currentParagraph = "";
        inList = false;
      }
      continue;
    }

    const isListStart = /^(\d+\.|[a-z]\.)\s/.test(line);
    const isGreeting = /^(Dear|Hi|Hello)\s/.test(line);
    const isClosing =
      /^(Best regards|Sincerely|Thank you|Regards|Kind regards),/i.test(line);
    const nextStartsCapital = /^[A-Z]/.test(nextLine);
    const nextIsList = /^(\d+\.|[a-z]\.)\s/.test(nextLine);
    const lineEndsSentence = /[.!?]$/.test(line);

    if (isGreeting) {
      if (currentParagraph.trim()) {
        paragraphs.push(currentParagraph.trim());
        currentParagraph = "";
      }
      paragraphs.push(line);
      currentParagraph = "";
      inList = false;
      continue;
    }

    if (isClosing) {
      if (currentParagraph.trim()) {
        paragraphs.push(currentParagraph.trim());
        currentParagraph = "";
      }
      paragraphs.push(line);
      currentParagraph = "";
      inList = false;
      continue;
    }

    if (isListStart) {
      if (!inList && currentParagraph.trim()) {
        paragraphs.push(currentParagraph.trim());
        currentParagraph = "";
      }
      inList = true;
      if (currentParagraph) {
        currentParagraph += "\n" + line;
      } else {
        currentParagraph = line;
      }

      if (!nextIsList && !nextLine) {
        paragraphs.push(currentParagraph.trim());
        currentParagraph = "";
        inList = false;
      }
      continue;
    }

    if (inList) {
      if (currentParagraph.trim()) {
        paragraphs.push(currentParagraph.trim());
        currentParagraph = "";
      }
      inList = false;
    }

    if (
      lineEndsSentence &&
      nextStartsCapital &&
      !nextIsList &&
      currentParagraph.trim()
    ) {
      currentParagraph += " " + line;
      paragraphs.push(currentParagraph.trim());
      currentParagraph = "";
    } else {
      if (currentParagraph) {
        currentParagraph += " " + line;
      } else {
        currentParagraph = line;
      }
    }
  }

  if (currentParagraph.trim()) {
    paragraphs.push(currentParagraph.trim());
  }

  let result = paragraphs.join("\n\n");

  const finalParagraphs: string[] = [];
  const splitParagraphs = result.split("\n\n");

  for (const para of splitParagraphs) {
    if (para.length > 200) {
      const sentences = para.split(/([.!?])\s+([A-Z])/);
      if (sentences.length > 3) {
        let currentSentence = "";
        for (let i = 0; i < sentences.length; i++) {
          if (i % 3 === 0 && sentences[i]) {
            currentSentence += sentences[i];
          } else if (i % 3 === 1 && sentences[i]) {
            currentSentence += sentences[i];
          } else if (i % 3 === 2 && sentences[i]) {
            currentSentence += sentences[i];
            if (currentSentence.trim().length > 50) {
              finalParagraphs.push(currentSentence.trim());
              currentSentence = "";
            }
          }
        }
        if (currentSentence.trim()) {
          finalParagraphs.push(currentSentence.trim());
        }
      } else {
        finalParagraphs.push(para);
      }
    } else {
      finalParagraphs.push(para);
    }
  }

  result = finalParagraphs.join("\n\n");

  result = result.replace(/\n{3,}/g, "\n\n").trim();

  return result;
}

export async function POST(req: Request) {
  try {
    const { userId } = await auth();

    if (!userId) {
      return new Response("Unauthorized", { status: 401 });
    }

    let body: ChatRequest;
    try {
      body = await req.json();
    } catch (parseError) {
      console.error("Failed to parse request body:", parseError);
      return new Response(JSON.stringify({ error: "Invalid request body" }), {
        status: 400,
        headers: { "Content-Type": "application/json" },
      });
    }

    const { messages } = body;

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return new Response(
        JSON.stringify({ error: "Messages array is required" }),
        { status: 400, headers: { "Content-Type": "application/json" } },
      );
    }

    const lastMessage = messages[messages.length - 1];
    if (!lastMessage?.content) {
      return new Response(
        JSON.stringify({ error: "No message content provided" }),
        { status: 400, headers: { "Content-Type": "application/json" } },
      );
    }

    if (!env.OPENROUTER_API_KEY) {
      console.error("OPENROUTER_API_KEY is not configured");
      return new Response(
        JSON.stringify({
          error:
            "OpenRouter API key is not configured. Please configure OPENROUTER_API_KEY in your environment variables.",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    const openai = new OpenAI({
      baseURL: "https://openrouter.ai/api/v1",
      apiKey: env.OPENROUTER_API_KEY,
      defaultHeaders: {
        "HTTP-Referer": "https://vectormail-ai.vercel.app",
        "X-Title": "VectorMail AI",
      },
    });

    const userMessage = lastMessage.content;
    const isEmail = isEmailRequest(userMessage, messages);
    const isSendRequest = isSendEmailRequest(userMessage);

    if (isSendRequest) {
      const emailAddresses = extractEmailAddresses(userMessage);
      if (emailAddresses.length === 0) {
        return new Response(
          JSON.stringify({
            error: "No email address found",
            message: "Please provide an email address to send to.",
          }),
          { status: 400, headers: { "Content-Type": "application/json" } },
        );
      }

      const lastEmail = await extractEmailFromConversation(messages, openai);
      if (!lastEmail) {
        return new Response(
          JSON.stringify({
            error: "No email found",
            message:
              "I couldn't find a generated email to send. Please generate an email first, then ask me to send it.",
          }),
          { status: 400, headers: { "Content-Type": "application/json" } },
        );
      }

      const account = await db.account.findFirst({
        where: { userId },
        select: {
          id: true,
          emailAddress: true,
          name: true,
          token: true,
        },
      });

      if (!account || !account.token) {
        return new Response(
          JSON.stringify({
            error: "No account found",
            message: "Please connect an email account first.",
          }),
          { status: 404, headers: { "Content-Type": "application/json" } },
        );
      }

      const enableEmailSend =
        env.ENABLE_EMAIL_SEND ?? process.env.ENABLE_EMAIL_SEND === "true";
      if (!enableEmailSend) {
        return new Response(
          JSON.stringify({
            error: "Email sending is disabled",
            message:
              "Email sending is currently disabled. Please contact support.",
          }),
          { status: 403, headers: { "Content-Type": "application/json" } },
        );
      }

      try {
        const emailAccount = new Account(account.id, account.token);

        const formattedBody = lastEmail.body
          .split("\n\n")
          .map(
            (para) =>
              `<p style="margin: 0 0 12px 0; line-height: 1.6;">${para.replace(/\n/g, "<br>")}</p>`,
          )
          .join("");

        const watermark = `<div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #e0e0e0; text-align: center; width: 100%;"><div style="color: #999999; font-size: 11px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; display: inline-block; margin: 0 auto;">Generated by VectorMail</div></div>`;
        const emailBodyWithWatermark = formattedBody + watermark;

        await emailAccount.sendEmail({
          from: {
            address: account.emailAddress,
            name: account.name || account.emailAddress,
          },
          to: emailAddresses.map((email) => ({
            address: email,
            name: email,
          })),
          subject: lastEmail.subject,
          body: emailBodyWithWatermark,
        });

        return new Response(
          JSON.stringify({
            message: `Email sent successfully to ${emailAddresses.join(", ")}!`,
            type: "conversation",
            emailSent: true,
            recipient: emailAddresses[0],
          }),
          {
            headers: {
              "Content-Type": "application/json",
              "Cache-Control": "no-cache",
            },
          },
        );
      } catch (error) {
        console.error("Error sending email:", error);

        let errorMessage = "Unknown error";
        let statusCode = 500;

        if (error instanceof Error) {
          errorMessage = error.message;
          const errorWithStatus = error as unknown as {
            status?: number;
            response?: unknown;
          };
          if (errorWithStatus.status) {
            statusCode = errorWithStatus.status;
          }

          if (errorMessage.includes("Request failed with status code")) {
            const statusMatch = errorMessage.match(/status code (\d+)/);
            if (statusMatch) {
              statusCode = parseInt(statusMatch[1] || "500", 10);
            }
          }
        }

        return new Response(
          JSON.stringify({
            error: "Failed to send email",
            message: `Could not send the email: ${errorMessage}. Please try again.`,
            details: error instanceof Error ? error.message : undefined,
          }),
          {
            status: statusCode,
            headers: { "Content-Type": "application/json" },
          },
        );
      }
    }

    let systemPrompt: string;
    let userPrompt: string;

    if (isEmail) {
      const previousEmail = messages
        .slice()
        .reverse()
        .find((msg) => msg.role === "assistant" && msg.emailData);

      const isRegeneration = previousEmail !== undefined;

      systemPrompt = `You are a professional AI email assistant that generates complete email drafts based on user summaries.

Your task is to generate a professional email with a clear subject line and well-written body, plus provide 2-3 alternative suggestions.

IMPORTANT: You MUST respond with ONLY valid JSON. No markdown, no code blocks, no explanations - just pure JSON.

The JSON structure must be:
{
  "subject": "Email subject line here",
  "body": "Complete email body with proper greeting, content, and closing",
  "suggestions": [
    {
      "subject": "Alternative subject 1",
      "body": "Alternative email body 1"
    },
    {
      "subject": "Alternative subject 2", 
      "body": "Alternative email body 2"
    }
  ]
}

üö®üö®üö® CRITICAL FORMATTING RULES - YOU MUST FOLLOW THESE EXACTLY - NO EXCEPTIONS üö®üö®üö®

PARAGRAPH SPACING (MOST IMPORTANT - THIS IS MANDATORY):
- EVERY paragraph MUST be separated by EXACTLY \\n\\n (double newline)
- NEVER use single \\n between paragraphs - ALWAYS use \\n\\n
- NEVER combine multiple paragraphs into one - EACH paragraph must be on separate lines with \\n\\n between them
- After greeting: ALWAYS use \\n\\n before first paragraph
- Before closing: ALWAYS use \\n\\n after last paragraph
- Between EVERY paragraph: ALWAYS use \\n\\n
- If you write multiple sentences that form separate thoughts, they MUST be in separate paragraphs with \\n\\n between them

LIST FORMATTING:
- ALWAYS add \\n\\n before lists
- ALWAYS add \\n\\n after lists
- Each list item on its own line
- Use ONLY numbers (1., 2., 3.) or letters (a., b., c.)
- NO symbols ever

SECTION HEADINGS:
- If you use section headings, add \\n\\n before heading and \\n\\n after heading

FORMATTING RULES - NO SYMBOLS ALLOWED:
- FORBIDDEN: Do NOT use ANY symbols - NO asterisks (*), NO double asterisks (**), NO triple asterisks (***), NO dashes (-), NO dots (‚Ä¢), NO special characters
- For lists, use ONLY numbers (1., 2., 3.) or letters (a., b., c.) - NO symbols
- NEVER use asterisks (*), dashes (-), dots (‚Ä¢), or any other symbols for lists or emphasis
- Keep formatting clean and professional with plain text only - NO markdown symbols at all

CORRECT FORMAT EXAMPLE (COPY THIS STRUCTURE):
Dear [Name],\\n\\nThank you for meeting with me. I wanted to follow up on our discussion.\\n\\n1. First key point\\na. Sub-point with details\\nb. Another sub-point\\n2. Second key point\\na. Sub-point details\\n\\nNext Steps:\\n\\n1. Action item one\\n2. Action item two\\n\\nBest regards,\\n[Your name]

ABSOLUTELY FORBIDDEN - DO NOT USE:
* Asterisks
- Dashes
‚Ä¢ Dots
Any symbols at all

GUIDELINES:
- Write professional, clear, and concise emails
- Use appropriate greetings (Dear, Hi, Hello) and closings (Best regards, Sincerely, Thank you)
- Make the subject line specific and actionable
- Ensure the body is well-structured with proper paragraphs and spacing
- Use proper line breaks and spacing for readability
- Suggestions should offer different tones (formal/casual) or approaches
- Return ONLY the JSON object, nothing else`;

      if (isRegeneration) {
        const previousEmailContext = previousEmail?.emailData
          ? `Previous email subject: ${previousEmail.emailData.subject}\nPrevious email body (for reference only): ${previousEmail.emailData.body.substring(0, 500)}...`
          : "";

        const wantsLongerEmail =
          /(more explanatory|more detailed|expand|bigger|longer|lengthy|comprehensive|elaborate|extend)/i.test(
            userMessage,
          );

        userPrompt = `The user wants a ${wantsLongerEmail ? "longer, more detailed, and more comprehensive" : userMessage.toLowerCase().includes("better") ? "better" : "different"} version of a previously generated email. Generate a new, improved email with better formatting, structure, and content. ${wantsLongerEmail ? "Make it significantly longer with more detailed explanations, additional context, and comprehensive coverage of all topics." : ""} Return ONLY valid JSON in the exact format specified.

${previousEmailContext ? `\n${previousEmailContext}\n` : ""}
‚ö†Ô∏è CRITICAL FORMATTING REQUIREMENTS - MUST FOLLOW EXACTLY (ESPECIALLY FOR LONGER EMAILS):
1. ALWAYS use \\n\\n (double newline) between paragraphs - this is MANDATORY
2. ALWAYS use \\n (single newline) for line breaks within content
3. ALWAYS add \\n\\n before lists and \\n\\n after lists for proper spacing
4. ALWAYS put each list item on its own line
5. ALWAYS use proper spacing: blank line before sections, blank line after sections
6. NEVER use symbols - only numbers (1., 2., 3.) or letters (a., b., c.) for lists
7. NEVER combine paragraphs - each paragraph must be separated by \\n\\n
8. FOR LONGER EMAILS: Break content into clear sections with proper headings and spacing
9. FOR LONGER EMAILS: Each section should be separated by \\n\\n before the section heading and \\n\\n after the section content
10. FOR LONGER EMAILS: Maintain consistent structure - greeting, introduction, main sections, conclusion, closing

FORMAT EXAMPLE FOR LONGER EMAILS (copy this structure exactly):
Dear [Name],\\n\\n[Opening paragraph]\\n\\n[Section Heading 1]\\n\\n[Detailed paragraph about section 1]\\n\\n[Sub-points or details]\\n\\n1. First main point\\na. Detailed explanation\\nb. Additional context\\n2. Second main point\\na. Detailed explanation\\n\\n[Section Heading 2]\\n\\n[Detailed paragraph about section 2]\\n\\n[More content]\\n\\n[Section Heading 3]\\n\\n[Detailed paragraph]\\n\\n[Conclusion paragraph]\\n\\nBest regards,\\n[Name]

User request: ${userMessage}`;
      } else {
        userPrompt = `Generate an email based on this summary. Return ONLY valid JSON in the exact format specified.

üö® CRITICAL FORMATTING REQUIREMENTS - MUST FOLLOW EXACTLY:
1. ALWAYS use \\n\\n (double newline) between EVERY paragraph - this is MANDATORY
2. NEVER use single \\n between paragraphs - ALWAYS use \\n\\n
3. ALWAYS add \\n\\n before lists and \\n\\n after lists
4. Each list item on its own line
5. NO symbols - use only numbers (1., 2., 3.) or letters (a., b., c.) for lists
6. Use plain text formatting only
7. After greeting, use \\n\\n before first paragraph
8. Before closing, use \\n\\n after last paragraph

FORMAT EXAMPLE:
Dear [Name],\\n\\n[First paragraph]\\n\\n[Second paragraph]\\n\\n1. First item\\n2. Second item\\n\\n[Third paragraph]\\n\\nBest regards,\\n[Name]

Summary: ${userMessage}`;
      }
    } else {
      systemPrompt = `You are AI Buddy, a helpful, friendly, and knowledgeable AI assistant. You can help with a wide variety of tasks and questions.

YOUR CAPABILITIES:
1. Casual Chat: Engage in friendly, natural conversations
2. Email Generation: Help compose, draft, and write professional emails
3. Suggestions & Advice: Provide recommendations, tips, and suggestions on various topics
4. General Questions: Answer questions about meetings, schedules, calendars, work, life, technology, science, history, and any other topic
5. Problem Solving: Help solve problems, brainstorm ideas, and think through challenges
6. Explanations: Explain concepts, how things work, and provide tutorials
7. Coding Help: Assist with programming, debugging, and technical questions
8. Content Writing: Help write, edit, and improve written content

CRITICAL INSTRUCTIONS FOR ACCURATE RESPONSES:
1. ALWAYS answer the specific question asked - provide helpful, relevant information
2. Read the user's question carefully and understand exactly what they're asking
3. Provide direct, clear answers that directly address the question
4. For questions about meetings, schedules, or calendars: Provide helpful information about how to manage meetings, best practices for scheduling, or general advice (even if you don't have access to their specific calendar)
5. For email-related questions: Offer to help generate emails or provide email writing advice
6. For general knowledge questions: Answer accurately based on your knowledge
7. If the question is unclear, ask for clarification rather than guessing
8. Maintain conversation context from previous messages when relevant
9. Be helpful, friendly, and conversational - engage naturally with the user
10. DO NOT refuse to answer questions - always try to be helpful, even if you need to explain limitations

IMPORTANT FORMATTING RULES - NO SYMBOLS ALLOWED:
- FORBIDDEN: Do NOT use ANY symbols - NO asterisks (*), NO double asterisks (**), NO triple asterisks (***), NO dashes (-), NO dots (‚Ä¢), NO special characters
- For lists, use ONLY numbers (1., 2., 3.) or letters (a., b., c.) - NO symbols
- NEVER use asterisks (*), dashes (-), dots (‚Ä¢), or any other symbols for lists or emphasis
- Use plain text formatting only - NO markdown symbols at all
- Keep formatting clean and professional with plain text only

SPECIFIC QUESTION HANDLING:
- Questions about meetings/schedules: Provide helpful information about meeting management, scheduling best practices, or suggest checking their email/calendar. Be helpful and informative.
- Questions about emails: Offer to help generate, draft, or improve emails
- General knowledge questions: Answer accurately and thoroughly
- Casual conversation: Engage naturally and be friendly
- Requests for suggestions: Provide thoughtful, practical suggestions

Remember: Your goal is to be helpful and answer questions. Always try to provide value, even if you need to explain limitations or suggest alternatives. Be accurate, helpful, and stay on topic.`;

      userPrompt = userMessage;
    }

    const wantsLongerEmail =
      isEmail &&
      /(more explanatory|more detailed|expand|bigger|longer|lengthy|comprehensive|elaborate|extend)/i.test(
        userMessage,
      );
    const maxTokens = wantsLongerEmail ? 3000 : isEmail ? 2000 : 2000;

    let completion;
    try {
      const completionMessages = isEmail
        ? [
            { role: "system" as const, content: systemPrompt },
            { role: "user" as const, content: userPrompt },
          ]
        : (() => {
            const conversationMessages = messages
              .filter((msg) => msg.role !== "system")
              .map((msg) => ({
                role: msg.role as "user" | "assistant",
                content: msg.content,
              }));

            return [
              { role: "system" as const, content: systemPrompt },
              ...conversationMessages,
            ];
          })();

      let model = "anthropic/claude-3-haiku";

      try {
        completion = await openai.chat.completions.create({
          model: model,
          messages: completionMessages,
          max_tokens: maxTokens,
          temperature: isEmail ? 0.7 : 0.3,
          ...(isEmail && { response_format: { type: "json_object" } }),
        });
      } catch (primaryError) {
        console.warn(
          "Primary model (Claude Haiku) failed, trying GPT-4o-mini:",
          primaryError,
        );
        try {
          model = "openai/gpt-4o-mini";
          completion = await openai.chat.completions.create({
            model: model,
            messages: completionMessages,
            max_tokens: maxTokens,
            temperature: isEmail ? 0.7 : 0.3,
            ...(isEmail && { response_format: { type: "json_object" } }),
          });
        } catch (secondaryError) {
          console.warn(
            "Secondary model failed, trying Gemini:",
            secondaryError,
          );
          model = "google/gemini-2.5-flash";
          completion = await openai.chat.completions.create({
            model: model,
            messages: completionMessages,
            max_tokens: maxTokens,
            temperature: isEmail ? 0.7 : 0.3,
            ...(isEmail && { response_format: { type: "json_object" } }),
          });
        }
      }
    } catch (apiError) {
      console.error("OpenRouter API error:", apiError);
      const errorMessage =
        apiError instanceof Error
          ? apiError.message
          : "Failed to create chat completion";
      return new Response(
        JSON.stringify({
          error: "Failed to connect to AI service",
          details: errorMessage,
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    if (!completion || !completion.choices || completion.choices.length === 0) {
      console.error("Invalid completion response:", completion);
      return new Response(
        JSON.stringify({
          error: "Invalid AI response",
          details:
            "The AI service returned an empty or invalid response. Please try again.",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    const content = completion.choices[0]?.message?.content || "";

    if (!content || content.trim() === "") {
      console.error("Empty content in AI response");
      return new Response(
        JSON.stringify({
          error: "Empty AI response",
          details:
            "The AI service returned an empty response. Please try again.",
        }),
        { status: 500, headers: { "Content-Type": "application/json" } },
      );
    }

    if (isEmail) {
      let emailData;
      try {
        emailData = JSON.parse(content);
      } catch (parseError) {
        console.error("Failed to parse AI response directly:", parseError);
        console.error("AI response content:", content.substring(0, 500));

        const jsonMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (jsonMatch && jsonMatch[1]) {
          try {
            emailData = JSON.parse(jsonMatch[1]);
          } catch {
            const jsonObjectMatch = content.match(/\{[\s\S]*\}/);
            if (jsonObjectMatch && jsonObjectMatch[0]) {
              try {
                emailData = JSON.parse(jsonObjectMatch[0]);
              } catch {
                console.error(
                  "Failed to parse extracted JSON:",
                  jsonObjectMatch[0].substring(0, 200),
                );
                return new Response(
                  JSON.stringify({
                    error: "Failed to parse AI response",
                    details:
                      "The AI returned an invalid JSON format. Please try again.",
                    rawContent: content.substring(0, 200),
                  }),
                  {
                    status: 500,
                    headers: { "Content-Type": "application/json" },
                  },
                );
              }
            } else {
              return new Response(
                JSON.stringify({
                  error: "Failed to parse AI response",
                  details:
                    "The AI returned an invalid format. Please try again.",
                  rawContent: content.substring(0, 200),
                }),
                {
                  status: 500,
                  headers: { "Content-Type": "application/json" },
                },
              );
            }
          }
        } else {
          const jsonObjectMatch = content.match(/\{[\s\S]*\}/);
          if (jsonObjectMatch && jsonObjectMatch[0]) {
            try {
              emailData = JSON.parse(jsonObjectMatch[0]);
            } catch {
              return new Response(
                JSON.stringify({
                  error: "Failed to parse AI response",
                  details:
                    "The AI returned an invalid JSON format. Please try again.",
                  rawContent: content.substring(0, 200),
                }),
                {
                  status: 500,
                  headers: { "Content-Type": "application/json" },
                },
              );
            }
          } else {
            return new Response(
              JSON.stringify({
                error: "Failed to parse AI response",
                details: "The AI did not return valid JSON. Please try again.",
                rawContent: content.substring(0, 200),
              }),
              { status: 500, headers: { "Content-Type": "application/json" } },
            );
          }
        }
      }

      if (!emailData || typeof emailData !== "object") {
        return new Response(
          JSON.stringify({
            error: "Invalid email structure",
            details: "The AI response is not a valid object. Please try again.",
          }),
          { status: 500, headers: { "Content-Type": "application/json" } },
        );
      }

      if (!emailData.subject || !emailData.body) {
        return new Response(
          JSON.stringify({
            error: "Invalid email structure",
            details: `The AI response is missing required fields. Subject: ${!!emailData.subject}, Body: ${!!emailData.body}. Please try again.`,
          }),
          { status: 500, headers: { "Content-Type": "application/json" } },
        );
      }

      emailData.body = removeAllSymbols(emailData.body);
      emailData.body = normalizeEmailFormatting(emailData.body);

      const body = emailData.body;

      const paragraphs = body.split(/\n\n+/).filter((p: string) => p.trim());

      const finalParagraphs: string[] = [];

      for (const para of paragraphs) {
        const trimmed = para.trim();
        if (!trimmed) continue;

        if (trimmed.length > 300) {
          const sentences = trimmed.split(/([.!?])\s+([A-Z][a-z])/);

          if (sentences.length > 3) {
            let currentSentence = sentences[0] || "";
            for (let i = 1; i < sentences.length; i += 3) {
              if (sentences[i]) currentSentence += sentences[i];
              if (sentences[i + 1]) currentSentence += " " + sentences[i + 1];
              if (sentences[i + 2]) currentSentence += sentences[i + 2];

              if (
                currentSentence.trim().length > 50 &&
                /[.!?]\s*$/.test(currentSentence.trim())
              ) {
                finalParagraphs.push(currentSentence.trim());
                currentSentence = "";
              }
            }
            if (currentSentence.trim()) {
              finalParagraphs.push(currentSentence.trim());
            }
          } else {
            finalParagraphs.push(trimmed);
          }
        } else {
          finalParagraphs.push(trimmed);
        }
      }

      const result: string[] = [];
      for (let i = 0; i < finalParagraphs.length; i++) {
        const para = finalParagraphs[i] || "";
        const nextPara = finalParagraphs[i + 1] || "";
        const isGreeting = /^(Dear|Hi|Hello)\s/i.test(para);
        const isClosing =
          /^(Best regards|Sincerely|Thank you|Regards|Kind regards),/i.test(
            para,
          );

        result.push(para);

        if (isGreeting && nextPara && !/^(Dear|Hi|Hello)\s/i.test(nextPara)) {
        }
        if (isClosing && i > 0) {
        }
      }

      emailData.body = result
        .join("\n\n")
        .replace(/\n{3,}/g, "\n\n")
        .trim();

      if (emailData.suggestions && Array.isArray(emailData.suggestions)) {
        emailData.suggestions = emailData.suggestions.map(
          (suggestion: { subject: string; body: string }) => {
            let body = removeAllSymbols(suggestion.body);
            body = normalizeEmailFormatting(body);

            const suggestionBody = body;
            const suggestionParagraphs = suggestionBody
              .split(/\n\n+/)
              .filter((p: string) => p.trim());

            const finalSuggestionParagraphs: string[] = [];
            for (const para of suggestionParagraphs) {
              const trimmed = para.trim();
              if (!trimmed) continue;

              if (trimmed.length > 300) {
                const sentences = trimmed.split(/([.!?])\s+([A-Z][a-z])/);
                if (sentences.length > 3) {
                  let currentSentence = sentences[0] || "";
                  for (let i = 1; i < sentences.length; i += 3) {
                    if (sentences[i]) currentSentence += sentences[i];
                    if (sentences[i + 1])
                      currentSentence += " " + sentences[i + 1];
                    if (sentences[i + 2]) currentSentence += sentences[i + 2];

                    if (
                      currentSentence.trim().length > 50 &&
                      /[.!?]\s*$/.test(currentSentence.trim())
                    ) {
                      finalSuggestionParagraphs.push(currentSentence.trim());
                      currentSentence = "";
                    }
                  }
                  if (currentSentence.trim()) {
                    finalSuggestionParagraphs.push(currentSentence.trim());
                  }
                } else {
                  finalSuggestionParagraphs.push(trimmed);
                }
              } else {
                finalSuggestionParagraphs.push(trimmed);
              }
            }

            body = finalSuggestionParagraphs
              .join("\n\n")
              .replace(/\n{3,}/g, "\n\n")
              .trim();

            return {
              subject: suggestion.subject,
              body: body,
            };
          },
        );
      }

      return new Response(JSON.stringify(emailData), {
        headers: {
          "Content-Type": "application/json",
          "Cache-Control": "no-cache",
        },
      });
    } else {
      const cleanedContent = removeAllSymbols(content);

      return new Response(
        JSON.stringify({
          message: cleanedContent,
          type: "conversation",
        }),
        {
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-cache",
          },
        },
      );
    }
  } catch (error) {
    console.error("Buddy chat error:", error);

    const errorMessage =
      error instanceof Error ? error.message : "Unknown error";

    return new Response(
      JSON.stringify({
        error: "Failed to process chat request",
        details: errorMessage,
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      },
    );
  }
}
